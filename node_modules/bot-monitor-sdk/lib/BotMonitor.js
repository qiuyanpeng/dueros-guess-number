/**
 * Copyright (c) 2017 Baidu, Inc. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file BotMonitor class
 * @author liudesheng<liudesheng01@baidu.com>
 */

'use strict';

const https     = require('https');
const Request   = require('./Request');
const Response  = require('./Response');
const Config    = require('./Config');
const Certificate = require('./Certificate');

class BotMonitor {

    /**
     * constructor function
     *
     * @param {Object} postData request send from dueros.
     * @param {String} you bot private key.
     */
    constructor(postData) {
        this._requestStartTime = this.getMillisecond();
        this._requestEndTime = 0;
        this._request = new Request(postData);
        this._audioUrl = '';
        this._appName = '';
        this._packageName = '';
        this._deepLink = '';
        this._evenStartTime = 0;
        this._evenCostTime = 0;
        this._deviceEveStartTime = 0;
        this._deviceEvenCostTime = 0;
        this._userEventList = {};
        this._isEventMakePair = {};
        this._config = new Config();
        this._environment = 0;
        this._enabled = true;
    }

    /**
     * set environment
     *
     * @param {string} privateKey your openssl private key content
     * @param {string} environment you bot current status.0:debug 1:online
     */
    setEnvironmentInfo(privateKey, environment)
    {
        this._environment = environment;
        this._privateKey = privateKey;
        this._certificate = new Certificate(privateKey);
    }

    /**
     * enable or disable monitor
     *
     * @param {boolean} enabled is bot monitor sdk enable
     */
    setMonitorEnabled(enabled)
    {
        this._enabled = enabled;
    }


    /**
     * set response data
     *
     * @param {Object} response of return to dueros
     * @return null
     **/
    setResponseData(responseData) {
        if (this.isShouldDisable()) {
            return;
        }
        this._requestEndTime = this.getMillisecond();
        this._response = new Response(JSON.parse(responseData));
    }

    /**
     * when intent handler start,record current timestamp
     **/
    setEventStart() {
        if (this.isShouldDisable()) {
            return;
        }
        this._evenStartTime = this.getMillisecond();
    }

    /**
     * when intent handler ends,calculate current event execution time
     **/
    setEventEnd() {
        if (this.isShouldDisable()) {
            return;
        }
        this._evenCostTime = this.getMillisecond() - this._evenStartTime;
    }

    /**
     * when device event start,record current timestamp
     **/
    setDeviceEventStart()
    {
        if (this.isShouldDisable()) {
            return;
        }
        this._deviceEveStartTime = this.getMillisecond();
    }

    /**
     * when device event ends,calculate device event execution time
     **/
    setDeviceEventEnd()
    {
        if (this.isShouldDisable()) {
            return;
        }
        this._deviceEvenCostTime = this.getMillisecond() - this._deviceEveStartTime;
    }

    /**
     * define your own performance events,and call this funcion at the beginning of the event
     * Notice this function call must appear in pairs with setOprationToc
     * @param {string} a name used to uniquely identify as user event,it will be show in the
     * dueros develope platform.
     **/
    setOprationTic(taskName) {
        if (this.isShouldDisable()) {
            return;
        }
        if (taskName) {
            let currTime = this.getMillisecond();
            this._userEventList[taskName] = currTime;
            this._isEventMakePair[taskName] = false;
        }
    }

    /**
     * stop timing for an event,call this funcion at the end of the event
     * Notice this function call must appear in pairs with setOprationTic
     * @param {string} a name used to uniquely identify as user event
     **/
    setOprationToc(taskName) {
        if (this.isShouldDisable()) {
            return;
        }
        if (taskName) {
            let oldTime = this._userEventList[taskName];
            let currtime = this.getMillisecond();
            let costTime = 0;
            if (oldTime) {
                costTime = currtime - oldTime;
            }
            this._userEventList[taskName] = costTime;
            this._isEventMakePair[taskName] = true;
        }
    }

    /**
     * set open application name
     * @param {string} open application name
     **/
    setAppName(appName) {
        if (this.isShouldDisable()) {
            return;
        }
        if (appName) {
            this._appName = appName;
        }
    }

    /**
     * set package name
     * @param {string} the application package name
     **/
    setPackageName(packageName) {
        if (this.isShouldDisable()) {
            return;
        }
        if (packageName) {
            this._packageName = packageName;
        }
    }

    /**
     * set deepLink
     * @param {string} the url to open application
     **/
    setDeepLink(deepLink) {
        if (this.isShouldDisable()) {
            return;
        }
        if (deepLink) {
            this._deepLink = deepLink;
        }
    }

    /**
     * set audio url
     * @param {string} audio url
     **/
    setAudioUrl(audioUrl) {
        if (this.isShouldDisable()) {
            return;
        }
        if (audioUrl) {
            this._audioUrl = audioUrl;
        }
    }

    /**
     * get the current timestamp
     * @return {Long} timestamp
     **/
    getMillisecond() {
        return Date.now();
    }

    uploadData() {
        if (this.isShouldDisable()) {
            return;
        }
        let botId = this._request.getBotId();
        let sdkType = this._config.getSdkType();
        let sdkVersion = this._config.getSdkVersion();
        let requestId = this._request.getRequestId();
        let query = this._request.getQuery();
        let reason = this._request.getReason();
        let deviceId = this._request.getDeviceId();
        let requestType = this._request.getType();
        let userId   = this._request.getUserId();
        let intentName  = this._request.getIntentName();
        let sessionId = this._request.getSessionId();
        let location = this._request.getLocation();

        let slotName = this._response.getSlotName();
        let shouldEndSession = this._response.getShouldEndSession();
        let outputSpeech = this._response.getOutputSpeech();
        let reprompt = this._response.getReprompt();

        let sysEvent = {
            preEventList: [],
            postEventList: [],
            eventCostTime: this._evenCostTime,
            deviceEventCostTime: this._deviceEvenCostTime
        };

        let timestamp = parseInt(Date.now() / 1000, 10);
        let retData = {
            sdkType: sdkType,
            sdkVersion: sdkVersion,
            requestId: requestId,
            query: query,
            reason: reason,
            deviceId: deviceId,
            requestType: requestType,
            userId: userId,
            intentName: intentName,
            sessionId: sessionId,
            location: location,

            slotToElicit: slotName,
            shouldEndSession: shouldEndSession,
            outputSpeech: outputSpeech,
            reprompt: reprompt,
            audioUrl: this._audioUrl,
            appInfo: {
                appName: this._appName,
                packageName: this._packageName,
                deepLink: this._deepLink
            },
            requestStartTime: this._requestStartTime,
            requestEndTime: this._requestEndTime,
            timestamp: timestamp,
            sysEvent: sysEvent,
            usrEvent: this._userEventList
        };
        let jsonData = JSON.stringify({'serviceData': retData});
        let base64Data = new Buffer(jsonData).toString('base64');

        let pkversion = '';
        if (this._environment === 0) {
            pkversion = 'debug';
        } else {
            pkversion = 'online';
        }
        let at = this._certificate.getSign(base64Data + botId
            + timestamp.toString() + pkversion);
        if (!at || pkversion.length === 0) {
            return;
        }

        var opt = {
            method: 'POST',
            host: this._config.getUploadurl(),
            port: this._config.getUploadPort(),
            path: this._config.getUploadPath(),
            headers: {
                SIGNATURE: at,
                'Content-Length': Buffer.byteLength(base64Data),
                botId: botId,
                timestamp: timestamp,
                pkversion: pkversion
            }
        };

        let req = https.request(opt, function (res) {
        });
        req.write(base64Data);
        req.end();
    }

    isShouldDisable() {
        if (this._privateKey == null || this._privateKey.length === 0
            || !Number.isInteger(this._environment) || !this._enabled) {
            return true;
        }
        return false;
    }
}

module.exports = BotMonitor;